{"ast":null,"code":"import { padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\nlet intlDTCache = {};\nfunction getCachedDTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n  return dtf;\n}\nlet intlNumCache = {};\nfunction getCachedINF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n  return inf;\n}\nlet intlRelCache = {};\nfunction getCachedRTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    base,\n    ...cacheKeyOpts\n  } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n  return inf;\n}\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    const smaller = localeStr.substring(0, uIndex);\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n    } catch (e) {\n      options = getCachedDTF(smaller).resolvedOptions();\n    }\n    const {\n      numberingSystem,\n      calendar\n    } = options;\n    // return the smaller one so that we can append the calendar and numbering overrides to it\n    return [smaller, numberingSystem, calendar];\n  }\n}\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    localeStr += \"-u\";\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\";\n  }\n}\n\n/**\r\n * @private\r\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n    const {\n      padTo,\n      floor,\n      ...otherOpts\n    } = opts;\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = {\n        useGrouping: false,\n        ...opts\n      };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\r\n * @private\r\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    let z;\n    if (dt.zone.isUniversal) {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\n        // So we have to make do. Two cases:\n        // 1. The format options tell us to show the zone. We can't do that, so the best\n        // we can do is format the date in UTC.\n        // 2. The format options don't tell us to show the zone. Then we can adjust them\n        // the time and tell the formatter to show it to us in UTC, so that the time is right\n        // and the bad zone doesn't show up.\n        z = \"UTC\";\n        if (opts.timeZoneName) {\n          this.dt = dt;\n        } else {\n          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n        }\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n    const intlOpts = {\n      ...this.opts\n    };\n    if (z) {\n      intlOpts.timeZone = z;\n    }\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n  format() {\n    return this.dtf.format(this.dt.toJSDate());\n  }\n  formatToParts() {\n    return this.dtf.formatToParts(this.dt.toJSDate());\n  }\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\r\n * @private\r\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = {\n      style: \"long\",\n      ...opts\n    };\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\r\n * @private\r\n */\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n  static create(locale, numberingSystem, outputCalendar) {\n    let defaultToEN = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n  static fromObject() {\n    let {\n      locale,\n      numberingSystem,\n      outputCalendar\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n    this.weekdaysCache = {\n      format: {},\n      standalone: {}\n    };\n    this.monthsCache = {\n      format: {},\n      standalone: {}\n    };\n    this.meridiemCache = null;\n    this.eraCache = {};\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n    return this.fastNumbersCached;\n  }\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);\n    }\n  }\n  redefaultToEN() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone({\n      ...alts,\n      defaultToEN: true\n    });\n  }\n  redefaultToSystem() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone({\n      ...alts,\n      defaultToEN: false\n    });\n  }\n  months(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? {\n          month: length,\n          day: \"numeric\"\n        } : {\n          month: length\n        },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n  weekdays(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format ? {\n          weekday: length,\n          year: \"numeric\",\n          month: \"long\",\n          day: \"numeric\"\n        } : {\n          weekday: length\n        },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, \"weekday\"));\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n  meridiems() {\n    let defaultOK = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return listStuff(this, undefined, defaultOK, () => English.meridiems, () => {\n      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n      // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n      if (!this.meridiemCache) {\n        const intl = {\n          hour: \"numeric\",\n          hourCycle: \"h12\"\n        };\n        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, \"dayperiod\"));\n      }\n      return this.meridiemCache;\n    });\n  }\n  eras(length) {\n    let defaultOK = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = {\n        era: length\n      };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, \"era\"));\n      }\n      return this.eraCache[length];\n    });\n  }\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find(m => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n  numberFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n  dtFormatter(dt) {\n    let intlOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n  relFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n  listFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getCachedLF(this.intl, opts);\n  }\n  isEnglish() {\n    return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\");\n  }\n  equals(other) {\n    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n  }\n}","map":{"version":3,"names":["padStart","roundTo","hasRelative","English","Settings","DateTime","IANAZone","intlLFCache","getCachedLF","locString","opts","key","JSON","stringify","dtf","Intl","ListFormat","intlDTCache","getCachedDTF","DateTimeFormat","intlNumCache","getCachedINF","inf","NumberFormat","intlRelCache","getCachedRTF","base","cacheKeyOpts","RelativeTimeFormat","sysLocaleCache","systemLocale","resolvedOptions","locale","parseLocaleString","localeStr","uIndex","indexOf","options","smaller","substring","e","numberingSystem","calendar","intlConfigString","outputCalendar","mapMonths","f","ms","i","dt","utc","push","mapWeekdays","listStuff","loc","length","defaultOK","englishFn","intlFn","mode","listingMode","supportsFastNumbers","startsWith","intl","PolyNumberFormatter","constructor","forceSimple","padTo","floor","otherOpts","Object","keys","intlOpts","useGrouping","minimumIntegerDigits","format","fixed","Math","PolyDateFormatter","z","zone","isUniversal","gmtOffset","offset","offsetZ","create","valid","timeZoneName","fromMillis","ts","type","name","timeZone","toJSDate","formatToParts","PolyRelFormatter","isEnglish","style","rtf","count","unit","formatRelativeTime","numeric","Locale","fromOpts","defaultToEN","specifiedLocale","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar","resetCache","fromObject","numbering","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","fastNumbers","isActuallyEn","hasNoWeirdness","clone","alts","getOwnPropertyNames","redefaultToEN","redefaultToSystem","months","month","day","formatStr","extract","weekdays","weekday","year","meridiems","undefined","hour","hourCycle","map","eras","era","field","df","dtFormatter","results","matching","find","m","toLowerCase","value","numberFormatter","relFormatter","listFormatter","equals","other"],"sources":["C:/wepabbi/webappi/webappui/node_modules/luxon/src/impl/locale.js"],"sourcesContent":["import { padStart, roundTo, hasRelative } from \"./util.js\";\r\nimport * as English from \"./english.js\";\r\nimport Settings from \"../settings.js\";\r\nimport DateTime from \"../datetime.js\";\r\nimport IANAZone from \"../zones/IANAZone.js\";\r\n\r\n// todo - remap caching\r\n\r\nlet intlLFCache = {};\r\nfunction getCachedLF(locString, opts = {}) {\r\n  const key = JSON.stringify([locString, opts]);\r\n  let dtf = intlLFCache[key];\r\n  if (!dtf) {\r\n    dtf = new Intl.ListFormat(locString, opts);\r\n    intlLFCache[key] = dtf;\r\n  }\r\n  return dtf;\r\n}\r\n\r\nlet intlDTCache = {};\r\nfunction getCachedDTF(locString, opts = {}) {\r\n  const key = JSON.stringify([locString, opts]);\r\n  let dtf = intlDTCache[key];\r\n  if (!dtf) {\r\n    dtf = new Intl.DateTimeFormat(locString, opts);\r\n    intlDTCache[key] = dtf;\r\n  }\r\n  return dtf;\r\n}\r\n\r\nlet intlNumCache = {};\r\nfunction getCachedINF(locString, opts = {}) {\r\n  const key = JSON.stringify([locString, opts]);\r\n  let inf = intlNumCache[key];\r\n  if (!inf) {\r\n    inf = new Intl.NumberFormat(locString, opts);\r\n    intlNumCache[key] = inf;\r\n  }\r\n  return inf;\r\n}\r\n\r\nlet intlRelCache = {};\r\nfunction getCachedRTF(locString, opts = {}) {\r\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\r\n  const key = JSON.stringify([locString, cacheKeyOpts]);\r\n  let inf = intlRelCache[key];\r\n  if (!inf) {\r\n    inf = new Intl.RelativeTimeFormat(locString, opts);\r\n    intlRelCache[key] = inf;\r\n  }\r\n  return inf;\r\n}\r\n\r\nlet sysLocaleCache = null;\r\nfunction systemLocale() {\r\n  if (sysLocaleCache) {\r\n    return sysLocaleCache;\r\n  } else {\r\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\r\n    return sysLocaleCache;\r\n  }\r\n}\r\n\r\nfunction parseLocaleString(localeStr) {\r\n  // I really want to avoid writing a BCP 47 parser\r\n  // see, e.g. https://github.com/wooorm/bcp-47\r\n  // Instead, we'll do this:\r\n\r\n  // a) if the string has no -u extensions, just leave it alone\r\n  // b) if it does, use Intl to resolve everything\r\n  // c) if Intl fails, try again without the -u\r\n\r\n  const uIndex = localeStr.indexOf(\"-u-\");\r\n  if (uIndex === -1) {\r\n    return [localeStr];\r\n  } else {\r\n    let options;\r\n    const smaller = localeStr.substring(0, uIndex);\r\n    try {\r\n      options = getCachedDTF(localeStr).resolvedOptions();\r\n    } catch (e) {\r\n      options = getCachedDTF(smaller).resolvedOptions();\r\n    }\r\n\r\n    const { numberingSystem, calendar } = options;\r\n    // return the smaller one so that we can append the calendar and numbering overrides to it\r\n    return [smaller, numberingSystem, calendar];\r\n  }\r\n}\r\n\r\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\r\n  if (outputCalendar || numberingSystem) {\r\n    localeStr += \"-u\";\r\n\r\n    if (outputCalendar) {\r\n      localeStr += `-ca-${outputCalendar}`;\r\n    }\r\n\r\n    if (numberingSystem) {\r\n      localeStr += `-nu-${numberingSystem}`;\r\n    }\r\n    return localeStr;\r\n  } else {\r\n    return localeStr;\r\n  }\r\n}\r\n\r\nfunction mapMonths(f) {\r\n  const ms = [];\r\n  for (let i = 1; i <= 12; i++) {\r\n    const dt = DateTime.utc(2016, i, 1);\r\n    ms.push(f(dt));\r\n  }\r\n  return ms;\r\n}\r\n\r\nfunction mapWeekdays(f) {\r\n  const ms = [];\r\n  for (let i = 1; i <= 7; i++) {\r\n    const dt = DateTime.utc(2016, 11, 13 + i);\r\n    ms.push(f(dt));\r\n  }\r\n  return ms;\r\n}\r\n\r\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\r\n  const mode = loc.listingMode(defaultOK);\r\n\r\n  if (mode === \"error\") {\r\n    return null;\r\n  } else if (mode === \"en\") {\r\n    return englishFn(length);\r\n  } else {\r\n    return intlFn(length);\r\n  }\r\n}\r\n\r\nfunction supportsFastNumbers(loc) {\r\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\r\n    return false;\r\n  } else {\r\n    return (\r\n      loc.numberingSystem === \"latn\" ||\r\n      !loc.locale ||\r\n      loc.locale.startsWith(\"en\") ||\r\n      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\"\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\n\r\nclass PolyNumberFormatter {\r\n  constructor(intl, forceSimple, opts) {\r\n    this.padTo = opts.padTo || 0;\r\n    this.floor = opts.floor || false;\r\n\r\n    const { padTo, floor, ...otherOpts } = opts;\r\n\r\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\r\n      const intlOpts = { useGrouping: false, ...opts };\r\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\r\n      this.inf = getCachedINF(intl, intlOpts);\r\n    }\r\n  }\r\n\r\n  format(i) {\r\n    if (this.inf) {\r\n      const fixed = this.floor ? Math.floor(i) : i;\r\n      return this.inf.format(fixed);\r\n    } else {\r\n      // to match the browser's numberformatter defaults\r\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\r\n      return padStart(fixed, this.padTo);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\n\r\nclass PolyDateFormatter {\r\n  constructor(dt, intl, opts) {\r\n    this.opts = opts;\r\n\r\n    let z;\r\n    if (dt.zone.isUniversal) {\r\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\r\n      // That is why fixed-offset TZ is set to that unless it is:\r\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\r\n      // 2. Unsupported by the browser:\r\n      //    - some do not support Etc/\r\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\r\n      const gmtOffset = -1 * (dt.offset / 60);\r\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\r\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\r\n        z = offsetZ;\r\n        this.dt = dt;\r\n      } else {\r\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.\r\n        // So we have to make do. Two cases:\r\n        // 1. The format options tell us to show the zone. We can't do that, so the best\r\n        // we can do is format the date in UTC.\r\n        // 2. The format options don't tell us to show the zone. Then we can adjust them\r\n        // the time and tell the formatter to show it to us in UTC, so that the time is right\r\n        // and the bad zone doesn't show up.\r\n        z = \"UTC\";\r\n        if (opts.timeZoneName) {\r\n          this.dt = dt;\r\n        } else {\r\n          this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\r\n        }\r\n      }\r\n    } else if (dt.zone.type === \"system\") {\r\n      this.dt = dt;\r\n    } else {\r\n      this.dt = dt;\r\n      z = dt.zone.name;\r\n    }\r\n\r\n    const intlOpts = { ...this.opts };\r\n    if (z) {\r\n      intlOpts.timeZone = z;\r\n    }\r\n    this.dtf = getCachedDTF(intl, intlOpts);\r\n  }\r\n\r\n  format() {\r\n    return this.dtf.format(this.dt.toJSDate());\r\n  }\r\n\r\n  formatToParts() {\r\n    return this.dtf.formatToParts(this.dt.toJSDate());\r\n  }\r\n\r\n  resolvedOptions() {\r\n    return this.dtf.resolvedOptions();\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nclass PolyRelFormatter {\r\n  constructor(intl, isEnglish, opts) {\r\n    this.opts = { style: \"long\", ...opts };\r\n    if (!isEnglish && hasRelative()) {\r\n      this.rtf = getCachedRTF(intl, opts);\r\n    }\r\n  }\r\n\r\n  format(count, unit) {\r\n    if (this.rtf) {\r\n      return this.rtf.format(count, unit);\r\n    } else {\r\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\r\n    }\r\n  }\r\n\r\n  formatToParts(count, unit) {\r\n    if (this.rtf) {\r\n      return this.rtf.formatToParts(count, unit);\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\n\r\nexport default class Locale {\r\n  static fromOpts(opts) {\r\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\r\n  }\r\n\r\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\r\n    const specifiedLocale = locale || Settings.defaultLocale;\r\n    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\r\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\r\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\r\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\r\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\r\n  }\r\n\r\n  static resetCache() {\r\n    sysLocaleCache = null;\r\n    intlDTCache = {};\r\n    intlNumCache = {};\r\n    intlRelCache = {};\r\n  }\r\n\r\n  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\r\n    return Locale.create(locale, numberingSystem, outputCalendar);\r\n  }\r\n\r\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\r\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\r\n\r\n    this.locale = parsedLocale;\r\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\r\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\r\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\r\n\r\n    this.weekdaysCache = { format: {}, standalone: {} };\r\n    this.monthsCache = { format: {}, standalone: {} };\r\n    this.meridiemCache = null;\r\n    this.eraCache = {};\r\n\r\n    this.specifiedLocale = specifiedLocale;\r\n    this.fastNumbersCached = null;\r\n  }\r\n\r\n  get fastNumbers() {\r\n    if (this.fastNumbersCached == null) {\r\n      this.fastNumbersCached = supportsFastNumbers(this);\r\n    }\r\n\r\n    return this.fastNumbersCached;\r\n  }\r\n\r\n  listingMode() {\r\n    const isActuallyEn = this.isEnglish();\r\n    const hasNoWeirdness =\r\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\r\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\r\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\r\n  }\r\n\r\n  clone(alts) {\r\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\r\n      return this;\r\n    } else {\r\n      return Locale.create(\r\n        alts.locale || this.specifiedLocale,\r\n        alts.numberingSystem || this.numberingSystem,\r\n        alts.outputCalendar || this.outputCalendar,\r\n        alts.defaultToEN || false\r\n      );\r\n    }\r\n  }\r\n\r\n  redefaultToEN(alts = {}) {\r\n    return this.clone({ ...alts, defaultToEN: true });\r\n  }\r\n\r\n  redefaultToSystem(alts = {}) {\r\n    return this.clone({ ...alts, defaultToEN: false });\r\n  }\r\n\r\n  months(length, format = false, defaultOK = true) {\r\n    return listStuff(this, length, defaultOK, English.months, () => {\r\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\r\n        formatStr = format ? \"format\" : \"standalone\";\r\n      if (!this.monthsCache[formatStr][length]) {\r\n        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, \"month\"));\r\n      }\r\n      return this.monthsCache[formatStr][length];\r\n    });\r\n  }\r\n\r\n  weekdays(length, format = false, defaultOK = true) {\r\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\r\n      const intl = format\r\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\r\n          : { weekday: length },\r\n        formatStr = format ? \"format\" : \"standalone\";\r\n      if (!this.weekdaysCache[formatStr][length]) {\r\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\r\n          this.extract(dt, intl, \"weekday\")\r\n        );\r\n      }\r\n      return this.weekdaysCache[formatStr][length];\r\n    });\r\n  }\r\n\r\n  meridiems(defaultOK = true) {\r\n    return listStuff(\r\n      this,\r\n      undefined,\r\n      defaultOK,\r\n      () => English.meridiems,\r\n      () => {\r\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\r\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\r\n        if (!this.meridiemCache) {\r\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\r\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\r\n            (dt) => this.extract(dt, intl, \"dayperiod\")\r\n          );\r\n        }\r\n\r\n        return this.meridiemCache;\r\n      }\r\n    );\r\n  }\r\n\r\n  eras(length, defaultOK = true) {\r\n    return listStuff(this, length, defaultOK, English.eras, () => {\r\n      const intl = { era: length };\r\n\r\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\r\n      // to definitely enumerate them.\r\n      if (!this.eraCache[length]) {\r\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>\r\n          this.extract(dt, intl, \"era\")\r\n        );\r\n      }\r\n\r\n      return this.eraCache[length];\r\n    });\r\n  }\r\n\r\n  extract(dt, intlOpts, field) {\r\n    const df = this.dtFormatter(dt, intlOpts),\r\n      results = df.formatToParts(),\r\n      matching = results.find((m) => m.type.toLowerCase() === field);\r\n    return matching ? matching.value : null;\r\n  }\r\n\r\n  numberFormatter(opts = {}) {\r\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\r\n    // (in contrast, the rest of the condition is used heavily)\r\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\r\n  }\r\n\r\n  dtFormatter(dt, intlOpts = {}) {\r\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\r\n  }\r\n\r\n  relFormatter(opts = {}) {\r\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\r\n  }\r\n\r\n  listFormatter(opts = {}) {\r\n    return getCachedLF(this.intl, opts);\r\n  }\r\n\r\n  isEnglish() {\r\n    return (\r\n      this.locale === \"en\" ||\r\n      this.locale.toLowerCase() === \"en-us\" ||\r\n      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")\r\n    );\r\n  }\r\n\r\n  equals(other) {\r\n    return (\r\n      this.locale === other.locale &&\r\n      this.numberingSystem === other.numberingSystem &&\r\n      this.outputCalendar === other.outputCalendar\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}