{"ast":null,"code":"import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\"\n    });\n  }\n  return dtfCache[zone];\n}\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6\n};\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const {\n      type,\n      value\n    } = formatted[i];\n    const pos = typeToPos[type];\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\nlet ianaZoneCache = {};\n/**\r\n * A zone identified by an IANA identifier, like America/New_York\r\n * @implements {Zone}\r\n */\nexport default class IANAZone extends Zone {\n  /**\r\n   * @param {string} name - Zone name\r\n   * @return {IANAZone}\r\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\r\n   * Reset local caches. Should only be necessary in testing scenarios.\r\n   * @return {void}\r\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\r\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\r\n   * @param {string} s - The string to check validity on\r\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\r\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\r\n   * @return {boolean}\r\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\r\n   * Returns whether the provided string identifies a real zone\r\n   * @param {string} zone - The string to check\r\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\r\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\r\n   * @return {boolean}\r\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: zone\n      }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, _ref) {\n    let {\n      format,\n      locale\n    } = _ref;\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n    if (isNaN(date)) return NaN;\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}","map":{"version":3,"names":["formatOffset","parseZoneInfo","isUndefined","objToLocalTS","Zone","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","era","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","create","name","resetCache","isValidSpecifier","s","isValidZone","e","constructor","zoneName","valid","isUniversal","offsetName","ts","locale","offset","Date","isNaN","NaN","adOrBc","Math","abs","adjustedHour","asUTC","millisecond","asTS","over","equals","otherZone","isValid"],"sources":["C:/wepabbi/webappi/webappui/node_modules/luxon/src/zones/IANAZone.js"],"sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\r\nimport Zone from \"../zone.js\";\r\n\r\nlet dtfCache = {};\r\nfunction makeDTF(zone) {\r\n  if (!dtfCache[zone]) {\r\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\r\n      hour12: false,\r\n      timeZone: zone,\r\n      year: \"numeric\",\r\n      month: \"2-digit\",\r\n      day: \"2-digit\",\r\n      hour: \"2-digit\",\r\n      minute: \"2-digit\",\r\n      second: \"2-digit\",\r\n      era: \"short\",\r\n    });\r\n  }\r\n  return dtfCache[zone];\r\n}\r\n\r\nconst typeToPos = {\r\n  year: 0,\r\n  month: 1,\r\n  day: 2,\r\n  era: 3,\r\n  hour: 4,\r\n  minute: 5,\r\n  second: 6,\r\n};\r\n\r\nfunction hackyOffset(dtf, date) {\r\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\r\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\r\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\r\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\r\n}\r\n\r\nfunction partsOffset(dtf, date) {\r\n  const formatted = dtf.formatToParts(date);\r\n  const filled = [];\r\n  for (let i = 0; i < formatted.length; i++) {\r\n    const { type, value } = formatted[i];\r\n    const pos = typeToPos[type];\r\n\r\n    if (type === \"era\") {\r\n      filled[pos] = value;\r\n    } else if (!isUndefined(pos)) {\r\n      filled[pos] = parseInt(value, 10);\r\n    }\r\n  }\r\n  return filled;\r\n}\r\n\r\nlet ianaZoneCache = {};\r\n/**\r\n * A zone identified by an IANA identifier, like America/New_York\r\n * @implements {Zone}\r\n */\r\nexport default class IANAZone extends Zone {\r\n  /**\r\n   * @param {string} name - Zone name\r\n   * @return {IANAZone}\r\n   */\r\n  static create(name) {\r\n    if (!ianaZoneCache[name]) {\r\n      ianaZoneCache[name] = new IANAZone(name);\r\n    }\r\n    return ianaZoneCache[name];\r\n  }\r\n\r\n  /**\r\n   * Reset local caches. Should only be necessary in testing scenarios.\r\n   * @return {void}\r\n   */\r\n  static resetCache() {\r\n    ianaZoneCache = {};\r\n    dtfCache = {};\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\r\n   * @param {string} s - The string to check validity on\r\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\r\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\r\n   * @return {boolean}\r\n   */\r\n  static isValidSpecifier(s) {\r\n    return this.isValidZone(s);\r\n  }\r\n\r\n  /**\r\n   * Returns whether the provided string identifies a real zone\r\n   * @param {string} zone - The string to check\r\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\r\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\r\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\r\n   * @return {boolean}\r\n   */\r\n  static isValidZone(zone) {\r\n    if (!zone) {\r\n      return false;\r\n    }\r\n    try {\r\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  constructor(name) {\r\n    super();\r\n    /** @private **/\r\n    this.zoneName = name;\r\n    /** @private **/\r\n    this.valid = IANAZone.isValidZone(name);\r\n  }\r\n\r\n  /** @override **/\r\n  get type() {\r\n    return \"iana\";\r\n  }\r\n\r\n  /** @override **/\r\n  get name() {\r\n    return this.zoneName;\r\n  }\r\n\r\n  /** @override **/\r\n  get isUniversal() {\r\n    return false;\r\n  }\r\n\r\n  /** @override **/\r\n  offsetName(ts, { format, locale }) {\r\n    return parseZoneInfo(ts, format, locale, this.name);\r\n  }\r\n\r\n  /** @override **/\r\n  formatOffset(ts, format) {\r\n    return formatOffset(this.offset(ts), format);\r\n  }\r\n\r\n  /** @override **/\r\n  offset(ts) {\r\n    const date = new Date(ts);\r\n\r\n    if (isNaN(date)) return NaN;\r\n\r\n    const dtf = makeDTF(this.name);\r\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\r\n      ? partsOffset(dtf, date)\r\n      : hackyOffset(dtf, date);\r\n\r\n    if (adOrBc === \"BC\") {\r\n      year = -Math.abs(year) + 1;\r\n    }\r\n\r\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\r\n    const adjustedHour = hour === 24 ? 0 : hour;\r\n\r\n    const asUTC = objToLocalTS({\r\n      year,\r\n      month,\r\n      day,\r\n      hour: adjustedHour,\r\n      minute,\r\n      second,\r\n      millisecond: 0,\r\n    });\r\n\r\n    let asTS = +date;\r\n    const over = asTS % 1000;\r\n    asTS -= over >= 0 ? over : 1000 + over;\r\n    return (asUTC - asTS) / (60 * 1000);\r\n  }\r\n\r\n  /** @override **/\r\n  equals(otherZone) {\r\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\r\n  }\r\n\r\n  /** @override **/\r\n  get isValid() {\r\n    return this.valid;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}